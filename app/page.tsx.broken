"use client";

import { useEffect, useState } from "react";
import { onAuthStateChanged, signInAnonymously } from "firebase/auth";
import {
  collection,
  doc,
  limit,
  onSnapshot,
  orderBy,
  query,
  where,
} from "firebase/firestore";

import { auth, db } from "@/lib/firebase";
import { bootstrapUser } from "@/lib/userBootstrap";

/* =========================
   TYPES
   ========================= */

type ActivityItem = {
  label: string;
  points: number;
};

type TaskItem = {
  id: string;
  title: string;
};

/* =========================
   PAGE
   ========================= */

export default function Page() {
  const [loading, setLoading] = useState(false);
  const [user, setUser] = useState<any>(null);

  const [trustScore, setTrustScore] = useState<number | null>(null);
  const [recentActivity, setRecentActivity] = useState<ActivityItem[]>([]);

  const [availableTasks, setAvailableTasks] = useState<number | null>(null);
  const [helpRequests, setHelpRequests] = useState<number | null>(null);

  const [nearbyTasks, setNearbyTasks] = useState<TaskItem[]>([]);

  /* =========================
     AUTH + USER BOOTSTRAP
     ========================= */

  useEffect(() => {
    const unsub = onAuthStateChanged(auth, async (u) => {
      if (!u) {
        setUser(null);
        return;
      }

      setUser(u);
      await bootstrapUser(u.uid);

      const userRef = doc(db, "users", u.uid);

      onSnapshot(userRef, (snap) => {
        if (!snap.exists()) return;

        const data = snap.data();

        setTrustScore(
          typeof data.trustScore === "number"
            ? data.trustScore
            : null
        );

        setRecentActivity(
          Array.isArray(data.recentActivity)
            ? data.recentActivity
            : []
        );
      });

      const tasksRef = query(
        collection(db, "tasks"),
        where("status", "==", "open")
      );

      const helpRef = query(
        collection(db, "helpRequests"),
        where("uid", "==", u.uid)
      );

      onSnapshot(tasksRef, (snap) => {
        setAvailableTasks(snap.size);
      });

      onSnapshot(helpRef, (snap) => {
        setHelpRequests(snap.size);
      });

      const nearbyRef = query(
        collection(db, "tasks"),
        where("status", "==", "open"),
        orderBy("createdAt", "desc"),
        limit(5)
      );

      onSnapshot(nearbyRef, (snap) => {
        const list: TaskItem[] = [];
        snap.forEach((d) => {
          const data = d.data();
          if (typeof data.title === "string") {
            list.push({ id: d.id, title: data.title });
          }
        });
        setNearbyTasks(list);
      });
    });

    return () => unsub();
  }, []);

  /* =========================
     ACTIONS
     ========================= */

  const handleLogin = async () => {
    setLoading(true);
    await signInAnonymously(auth);
    setLoading(false);
  };

  const handlePostSkill = () => {
  };

  const handleFindWork = () => {
  };

  const handleRequestHelp = () => {
  };

  /* =========================
     UI
     ========================= */

  if (!user) {
    return (
      <main style={{ padding: 24 }}>
        <h1>Unibic</h1>
        <p>Skill exchange platform</p>
        <button onClick={handleLogin} disabled={loading}>
          {loading ? "Logging in..." : "Login"}
        </button>
      </main>
    );
  }

  return (
    <main style={{ padding: 16 }}>
      {/* TRUST SCORE */}
      <section>
        <h3>Trust Score</h3>
        <h1>{trustScore ?? "--"} / 1000</h1>
      </section>

      {/* RECENT ACTIVITY */}
      <section>
        <h4>Recent Activity</h4>
        {recentActivity.length === 0 ? (
          <p>No activity yet</p>
        ) : (
          <ul>
            {recentActivity.map((a, i) => (
              <li key={i}>
                {a.label} +{a.points}
              </li>
            ))}
          </ul>
        )}
      </section>

      {/* TODAY SUMMARY */}
      <section>
        <h3>Today’s Summary</h3>
        <p>Available Tasks: {availableTasks ?? "—"}</p>
        <p>Help Requests: {helpRequests ?? "—"}</p>
      </section>

      {/* ACTIONS */}
      <section>
        <h3>Quick Actions</h3>
        <button onClick={handlePostSkill}>Post Skill</button>
        <button onClick={handleFindWork}>Find Work</button>
        <button onClick={handleRequestHelp}>Request Help</button>
      </section>

      {/* NEARBY TASKS */}
      <section>
        <h3>Nearby Tasks</h3>
        {nearbyTasks.length === 0 ? (
          <p>No nearby tasks available</p>
        ) : (
          <ul>
            {nearbyTasks.map((t) => (
              <li key={t.id}>{t.title}</li>
            ))}
          </ul>
        )}
      </section>
    </main>
  );
}

/* =========================
   SKILL / TASK CREATION ENGINE (OPTION B - STEP 1)
   ========================= */

import { addDoc, serverTimestamp } from "firebase/firestore";

const createSkillPost = async () => {
  if (!user) return;

  try {
    await addDoc(collection(db, "skills"), {
      uid: user.uid,
      title: "Untitled Skill",
      createdAt: serverTimestamp(),
      status: "draft",
    });

  } catch (e) {
    console.error("SKILL CREATE ERROR", e);
  }
};


/* =========================
   SKILL POST FORM (OPTION B - STEP 2)
   ========================= */

const [showSkillForm, setShowSkillForm] = useState(false);
const [skillTitle, setSkillTitle] = useState("");
const [savingSkill, setSavingSkill] = useState(false);

const submitSkill = async () => {
  if (savingSkill) return;
  setErrorMsg(null);
  if (!user || !skillTitle.trim()) { setErrorMsg("Skill title cannot be empty"); return; }

  try {
    setSavingSkill(true);

    await addDoc(collection(db, "skills"), {
      uid: user.uid,
      title: skillTitle.trim(),
      createdAt: serverTimestamp(),
      status: "active",
    });

    setSkillTitle("");
    setShowSkillForm(false);
  } catch (e) {
    console.error("SKILL SAVE ERROR", e);
  } finally {
    setSavingSkill(false);
  }
};


{/* =========================
    SKILL FORM UI
    ========================= */}
{showSkillForm && (
  <section style={{ marginTop: 24 }}>
    <h3>Post a Skill</h3>

    <input
      type="text"
      placeholder="Skill title"
      value={skillTitle}
      onChange={(e) => setSkillTitle(e.target.value)}
      style={{ padding: 8, width: "100%", marginBottom: 12 }}
    />

    <button onClick={submitSkill} disabled={savingSkill || !skillTitle.trim()}>
      {savingSkill ? "Saving..." : "Submit Skill"}
    </button>

    <button
      onClick={() => setShowSkillForm(false)}
      style={{ marginLeft: 8 }}
    >
      Cancel
    </button>
  </section>
)}


/* =========================
   USER SKILLS LIST (OPTION B - STEP 3)
   ========================= */

const [mySkills, setMySkills] = useState<
  { id: string; title: string }[]
>([]);

useEffect(() => {
  if (!user) return;

  const skillsRef = query(
    collection(db, "skills"),
    where("uid", "==", user.uid),
    orderBy("createdAt", "desc")
  );

  const unsub = onSnapshot(skillsRef, (snap) => {
    const list: { id: string; title: string }[] = [];
    snap.forEach((d) => {
      const data = d.data();
      if (typeof data.title === "string") {
        list.push({ id: d.id, title: data.title });
      }
    });
    setMySkills(list);
  });

  return () => unsub();
}, [user]);


{/* =========================
    MY SKILLS LIST UI
    ========================= */}
<section style={{ marginTop: 32 }}>
  <h3>My Skills</h3>

  {mySkills.length === 0 ? (
    <p style={{ opacity: 0.6 }}>No skills posted yet</p>
  ) : (
    <ul>
      {mySkills.map((s) => (
        <li key={s.id}>{s.title} <button onClick={() => deleteSkill(s.id)}>Delete</button></li>
      ))}
    </ul>
  )}
</section>


/* =========================
   SKILL DELETE ENGINE (OPTION B - STEP 4)
   ========================= */

import { deleteDoc } from "firebase/firestore";

const deleteSkill = async (skillId: string) => {
  if (!confirm("Delete this skill?")) return;
  if (!user) return;

  try {
    await deleteDoc(doc(db, "skills", skillId));
  } catch (e) {
    console.error("SKILL DELETE ERROR", e);
  }
};


/* =========================
   SKILL EDIT ENGINE (OPTION B - STEP 5)
   ========================= */

import { updateDoc } from "firebase/firestore";

const [editingSkillId, setEditingSkillId] = useState<string | null>(null);
const [editingTitle, setEditingTitle] = useState("");

const startEditSkill = (id: string, title: string) => {
  setEditingSkillId(id);
  setEditingTitle(title);
};

const cancelEditSkill = () => {
  setEditingSkillId(null);
  setEditingTitle("");
};

const saveEditSkill = async () => {
  if (!user || !editingSkillId || !editingTitle.trim()) { setErrorMsg("Skill title cannot be empty"); return; }

  try {
    await updateDoc(doc(db, "skills", editingSkillId), {
      title: editingTitle.trim(),
    });
    cancelEditSkill();
  } catch (e) {
    console.error("SKILL UPDATE ERROR", e);
  }
};


/* =========================
   UX + VALIDATION STATE (OPTION B - STEP 6)
   ========================= */

const [errorMsg, setErrorMsg] = useState<string | null>(null);


{/* =========================
    ERROR FEEDBACK
    ========================= */}
{errorMsg && (
  <div style={{ color: "red", marginBottom: 12 }}>
    {errorMsg}
  </div>
)}


/* =========================
   HELP REQUEST ENGINE (OPTION E - STEP 1)
   ========================= */

import { addDoc, serverTimestamp } from "firebase/firestore";

const [showHelpForm, setShowHelpForm] = useState(false);
const [helpTitle, setHelpTitle] = useState("");
const [helpDesc, setHelpDesc] = useState("");
const [savingHelp, setSavingHelp] = useState(false);

const submitHelpRequest = async () => {
  if (!user || !helpTitle.trim() || savingHelp) return;

  try {
    setSavingHelp(true);

    await addDoc(collection(db, "helpRequests"), {
      uid: user.uid,
      title: helpTitle.trim(),
      description: helpDesc.trim(),
      status: "open",
      createdAt: serverTimestamp(),
    });

    setHelpTitle("");
    setHelpDesc("");
    setShowHelpForm(false);
  } catch (e) {
    console.error("HELP REQUEST ERROR", e);
  } finally {
    setSavingHelp(false);
  }
};


{/* =========================
    HELP REQUEST FORM UI
    ========================= */}
{showHelpForm && (
  <section style={{ marginTop: 24 }}>
    <h3>Request Help</h3>

    <input
      type="text"
      placeholder="Help title"
      value={helpTitle}
      onChange={(e) => setHelpTitle(e.target.value)}
      style={{ padding: 8, width: "100%", marginBottom: 8 }}
    />

    <textarea
      placeholder="Describe your problem (optional)"
      value={helpDesc}
      onChange={(e) => setHelpDesc(e.target.value)}
      style={{ padding: 8, width: "100%", marginBottom: 12 }}
    />

    <button
      onClick={submitHelpRequest}
      disabled={savingHelp || !helpTitle.trim()}
    >
      {savingHelp ? "Submitting..." : "Submit Request"}
    </button>

    <button
      onClick={() => setShowHelpForm(false)}
      style={{ marginLeft: 8 }}
    >
      Cancel
    </button>
  </section>
)}


/* =========================
   HELP REQUESTS LIST ENGINE (OPTION E - STEP 2)
   ========================= */

const [openHelpRequests, setOpenHelpRequests] = useState<
  { id: string; title: string; description?: string }[]
>([]);

useEffect(() => {
  if (!user) return;

  const helpRef = query(
    collection(db, "helpRequests"),
    where("status", "==", "open"),
    orderBy("createdAt", "desc"),
    limit(10)
  );

  const unsub = onSnapshot(helpRef, (snap) => {
    const list: {
      id: string;
  const acceptHelp = async (helpId: string) => {
    try {
      await updateDoc(doc(db, "helpRequests", helpId), {
        status: "accepted",
        helperUid: user?.uid || null,
      });
    } catch (e) {
      console.error("ACCEPT HELP ERROR", e);
    }
  };

      title: string;
      description?: string;
    }[] = [];

    snap.forEach((d) => {
      const data = d.data();
      if (typeof data.title === "string") {
        list.push({
          id: d.id,
          title: data.title,
          description:
            typeof data.description === "string"
              ? data.description
              : undefined,
        });
      }
    });

    setOpenHelpRequests(list);
  });
<section style={{ marginTop: 32 }}>
  <h3>Open Help Requests</h3>

  {openHelpRequests.length === 0 && (
    <p>No open help requests.</p>
  )}

  {openHelpRequests.length > 0 && (
    <div>
      {openHelpRequests.map((req) => (
        <div key={req.id}>
          <strong>{req.title}</strong>


{openHelpRequests.map((h) => (
  <li key={h.id} style={{ marginBottom: 8 }}>
    <strong>{h.title}</strong>
    {h.description && (
      <p style={{ margin: 0, opacity: 0.8 }}>
{openHelpRequests.map((h) => (
  <div key={h.id}>
    <span>{h.title}</span>
    <button onClick={() => acceptHelp(h.id)}>Accept</button>
  </div>
))}

  if (user.uid === helperUid) return;
  if (!user || user.uid !== helperUid) return;

  try {
    // 1. Mark help request completed
    await updateDoc(doc(db, "helpRequests", helpId), {
      status: "completed",
      completedAt: serverTimestamp(),
    });

    // 2. Increase helper trust score
    const userRef = doc(db, "users", helperUid);
    await updateDoc(userRef, {
      trustScore: increment(TRUST_REWARD),
      recentActivity: [
        {
          label: "Help completed",
          points: 10,
        },
      ],
    });

  } catch (e) {
    console.error("COMPLETE HELP ERROR", e);
  }
};


/* =========================
   ACCEPTED HELP LIST (FOR HELPER)
   ========================= */

const [acceptedHelps, setAcceptedHelps] = useState<
  { id: string; title: string; helperUid: string }[]
>([]);

useEffect(() => {
  if (!user) return;

  const ref = query(
    collection(db, "helpRequests"),
    where("status", "==", "accepted"),
    where("helperUid", "==", user.uid)
  );

  const unsub = onSnapshot(ref, (snap) => {
    const list: {
      id: string;
      title: string;
      helperUid: string;
    }[] = [];

    snap.forEach((d) => {
      const data = d.data();
      if (typeof data.title === "string") {
        list.push({
          id: d.id,
          title: data.title,
          helperUid: data.helperUid,
        });
      }
    });

    setAcceptedHelps(list);
  });

  return () => unsub();
}, [user]);


{/* =========================
    ACCEPTED HELP (COMPLETE FLOW)
    ========================= */}
<section style={{ marginTop: 32 }}>
  <h3>My Accepted Helps</h3>

  {acceptedHelps.length === 0 ? (
    <p style={{ opacity: 0.6 }}>
      No accepted help requests
    </p>
  ) : (
    <ul>
      {acceptedHelps.map((h) => (
        <li key={h.id} style={{ marginBottom: 8 }}>
          <strong>{h.title}</strong>

          <button
            onClick={() =>
              completeHelpRequest(h.id, h.helperUid)
            }
            style={{ marginLeft: 8 }}
          >
            Complete
          </button>
        </li>
      ))}
    </ul>
  )}
</section>


/* =========================
   TRUST ENGINE RULES (OPTION F - STEP 1)
   ========================= */

const TRUST_MAX = 1000;
const TRUST_MIN = 0;
const TRUST_REWARD = 10;

const clampTrust = (value: number) => {
  if (value > TRUST_MAX) return TRUST_MAX;
  if (value < TRUST_MIN) return TRUST_MIN;
  return value;
};


/* =========================
   TRUST COOLDOWN GUARD
   ========================= */

const canRewardTrust = (
  lastActivity?: { label: string; points: number }
) => {
  if (!lastActivity) return true;
  if (lastActivity.label === "Help completed") return false;
  return true;
};


/* =========================
   TRUST PENALTY RULES (OPTION F - STEP 2)
   ========================= */

const TRUST_PENALTY_REJECT = -5;
const TRUST_PENALTY_MISUSE = -20;
const TRUST_PENALTY_FALSE_ACTIVITY = -15;


/* =========================
   APPLY TRUST PENALTY
   ========================= */

const applyTrustPenalty = async (
  targetUid: string,
  reason: string,
  points: number
) => {
  try {
    const userRef = doc(db, "users", targetUid);

    await updateDoc(userRef, {
      trustScore: increment(points),
      recentActivity: [
        {
          label: reason,
          points,
        },
      ],
    });

  } catch (e) {
    console.error("TRUST PENALTY ERROR", e);
  }
};


/* =========================
   TRUST PENALTY HOOKS (EXAMPLES)
   ========================= */

// When helper rejects accepted help
const onHelpRejected = async (helperUid: string) => {
  await applyTrustPenalty(
    helperUid,
    "Help rejected",
    TRUST_PENALTY_REJECT
  );
};

// When misuse reported
const onMisuseReported = async (targetUid: string) => {
  await applyTrustPenalty(
    targetUid,
    "Misuse reported",
    TRUST_PENALTY_MISUSE
  );
};

